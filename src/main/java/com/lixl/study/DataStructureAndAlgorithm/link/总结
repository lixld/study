缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的
CPU 缓存、
数据库缓存、
浏览器缓存
等等。

缓存大小有限制，当缓存被用满时，哪些数据被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略
常见的策略有：
FIFO:（fist in first out）先进先出
LFU:(least Frequently Used)最少使用策略
LRU:(least Recently Used) 最近最少使用策略

链表：不需要连续的内存空间，通过指针把内存块串在一起

------------------单链表------------------
我们把内存块称为链表的"结点"。为了把结点串联起来，每个链表的节点，除了存储数据外，还需要记录链表上的下一个节点的地址（后续指针）
特殊节点：
第一个结点：头结点
最后一个节点：尾结点 --指针指向一个空地址NULL

-------------------循环链表---------------
和单链表唯一区别在于：尾节点：指针指向头结点

-------------------双向链表---------------
支持两个方向：每个节点不止有一后继指针next指向后面的结点，还有前驱指针prev指向前面的结点。
需要额外的两个空间来存储前驱节点指针和 后续节点指针


LinkedHashMap就用到了双向链表


用空间换时间

LRU算法实现：维护一个有序单链表，越靠近链表尾部的是结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表（查找缓存）

1.如果此数据之前已经被缓存在链表中，我们遍历得到这数据对应的节点，并将其从原来的位置删除，然后再插入到链表的头部。
2.如果此数据没有在缓存链表中，又可以分两种情况：
如果此时缓存未满，则将此节点直接插入到链表头部；
如果此时缓存已满，则把尾部节点删除，将新的数据结点插入到链表头部了；


带头链表：不管链表是不是空，header指针都会一直指向这个哨兵结点。我们把这种有哨兵结点的链表叫：。
不带头链表：相反，没有哨兵结点的链表

哨兵结点不存储数据。因为哨兵结点一直存在，所有插入第一个结点和插入其他结点，删除最后一个节点和删除其他结点，都可以统一为相同的代码逻辑
实际上，这种使用哨兵简化编程难度的技巧。在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。


注意留意边界条件处理：

举例画图，辅助思考--举例法,画图法
可以找一个具体的例子，把它画在纸上，释放一些脑容量。留更多的给逻辑思考。这样就会感觉到思路清晰很多。

多写多练，没有捷径




链表 VS 数组性能大比拼






