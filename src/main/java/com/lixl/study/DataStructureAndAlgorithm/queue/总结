基于链表实现的队列，可以是一个支持无限排队的无界队列（unbounded queue），但是会导致过多的请求排队，请求处理的时间过长。
所以针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的

基于数组实现的有界队列（bounded queue）,队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求会被拒绝，这种处理方式对于响应时间敏感的系统就更加合理。
不过设置一个合理的队列大小，也是非常有讲究的。 队列太多会导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能

队列可以应用在任何有限资源池中。对于队列请求。比如数据库连接池。
实际上、对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过队列这种数据结构来实现请求排队


工作中应用更加广泛的

阻塞队列：在队列基础上加了阻塞操作。队列为空时，dequeue()动作会被阻塞，因为没有数据可以被取，直到队列中有了数据才能返回；队列满时，enqueue()动作会被阻塞，直到队列中有空闲位置再插入数据，然后再返回
-----生产者+消费者模型----
这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。
而且不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”

并发队列：线程安全的队列：最简单直接的方式就是直接在dequeue()和enqueue()方法上加锁。但是锁的力度过大并发度会低，同一时刻只允许一个线程存或者取操作。
实际上基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。--这就是循环队列比链式队列应用更加广泛的原因。


线程池原理：线程池没有空闲时，新的任务请求线程资源时，，线程池如何处理呢？
一般两种策略：
1.非阻塞处理方式：直接拒绝请求
2.阻塞处理方式：请求排队，等有空闲线程时，取出排队的请求继续处理。--那么如何存储排队的请求呢？如果我们希望公平，那么就用队列先进先出
