api 接口签名 需要解决三个问题
1.请求是否合法：是否是我们规定的人?
2.请求是否被篡改：是否被第三方劫持并篡改参数
3.防止重复请求（防重放）；是否重复请求

签名逻辑
接口有公共参数：appkey/sign/timestamp/nonce/sign

######防止篡改
前端工作
规则：
1.拼接接口的所有参数、参数按照ASCII 码 从小到大排序 格式为- k1=v1&k2=v2&k3=v3 得到params
2.在params最后拼接 appkey秘钥
3.通过某种加密算法（或者hash）得到sign值（一般为Base64(HMAC_SHA1(params,appSecret))）
4.sign加到params中，将params 放入请求头中发送请求目标接口
-----以上就是生成签名的过程------

后端工作
后端从请求头中取到签名，
通过前端相同算法生产sign
比较生成的sign和请求头中sign相同，表示该请求没有被篡改

###防止重放####
仿冒者虽然无法轻易模仿签名规则，生成一模一样的签名
实际上，监听并截取到请求的片段，（把签名截取出来）伪造fake 模仿正式请求，欺骗服务器进行重复请求、造成安全问题！---这种攻击方式叫重放攻击（replay攻击）

解决方案：
timestamp + nonce

timestamp 请求端生成，（代表发送的时间），      ---放入到params中，放在请求头中发出。同时将timestamp也作为一个参数加入sign计算中
            后端收到请求，把timeStamp解析出来，判断当前时间 和 请求发送时间 是否相差10s(前后端协商定) 超过则直接抛出异常

nonce      请求端生成(随机数---一般放redis中) ---放入到params中，放在请求头中发出。同时将nonce也作为一个参数加入sign计算中
            后端收到请求，把timeStamp解析出来，判断nonce是否请求过（请求过的放redis中）如果redis中存在对应的nonce,就证明该次请求是重放请求,直接抛出异常